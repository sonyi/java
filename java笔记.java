

-----------------------------------面向对象-----------------------------------------

什么的对象？
	1、面向对象的一种编程方法。
	2、面向对象是一种思维方式。
	3、面向对数不是一种编程语言。
	
面向对象的三大特点：封装、继承和多态。

应该如何学习面向对象？
	1、掌握一门面向对象语言的语法。
	2、掌握面向对象的思维方式。
	3、属性面向对象的设计原则。
	4、掌握面向对象的设计模式。
	
面向对象的终极目标：消除程序中的重复代码。

什么是面向对象的思维方法？
	1、首先确定谁来做，其次确定怎么做。
	2、首先考虑整体，其次考虑局部。
	3、首先考虑抽象，其次考虑具体。
	

----------------------------------重载和构造函数--------------------------------------------
	
重载的定义：(overload)
	1、两个或者多个函数在同一个类当中。
	2、函数名相同。
	3、参数列表不同
	4、重载与返回值类型无关。
	
什么时候使用重载：函数功能相同，但参与运算的未知内容不同，就使用重载。

构造函数的作用：
	1、构造函数的函数名必须与类名相同。
	2、构造函数没有返回值类型的定义。
	3、使用new来调用构造函数。
	4、如果类里面没有构造函数，编译器会自动添加一个参数为空，方法体也为空的构造函数。
	5、如果类里面已经有构造函数了，编译器不再添加构造函数。
	
构造函数与一般函数的比较：
	1、写法上不同。
	2、运行上不同：
		1、构造函数是在对象一建立就运行，给对象初始化，而一般函数在调用时才开始运行。
		2、一个对象建立，构造函数只执行一次，而方法可以被对象调用多次。
		
什么时候定义构造函数？
	当分析事物时，该事物具备一些特性或者行为，那么将这些内容定义在构造函数中。
	
注意：一个类中默认会有一个空参数的构造函数，这个默认构造函数的权限和所属类一致，如果类被public修饰，
		那么默认的构造函数也带public修饰符，如果没有，默认构造函数也没有。	
		
构造代码块：
	作用：给对象初始化，对象一建立就运行，而且优先于构造函数执行。
	与构造函数区别：
		构造代码块是给所以对象进行统一初始化，而构造函数的给对应对象初始化。
		构造代码块中定义的是不同对象共性的初始化内容。
		
举例：Person p = new Person("zhangsan",20);执行这句语句时计算机都做了什么？
	1、因为new用到了Person.class，因此先找到Person.class类并加载到内存中。
	2、执行该类中static代码块，分配内存地址。
	3、在堆内存中开辟空间，分配内存地址。
	4、在堆内存中建立对象特有属性，并进行默认初始化。（属性值为null或者为0）
	5、对属性进行显示初始化。（对属性赋值）
	6、对对象进行构造代码块初始化。
	7、对对象进行对应的构造函数初始化。
	8、将内存地址赋给栈内存中的变量p。
	
静态代码块、构造代码块、构造函数的作用：
	静态代码块是给类进行初始化的。
	构造代码块是给对象进行初始化的。
	构造函数是给对应对象进行初始化的。
	
	
-----------------------this关键字----------------------------------------------
		
	1、this代表当前对象。
	2、不能放在静态方法里面。
	3、当局部变量和成员变量（全局变量）重名时，如果想访问成员变量时，用this.成员变量。
	4、this调用构造方法时，需要放在构造方法内的第一行。
	


-------------------------------继承初步------------------------------------------------
	
什么是继承：
	在面向对象的世界中，继承就是一个类得到另一个类当中的成员变量和成员方法。（extends）

java中只支持单继承。使用继承是为了减少重复代码。

继承的特点：
	1、提高代码的复用性。
	2、让类与类之间产生了关系，有了这个关系，才有了多态的特征。

注意：千万不要为了获取其他类中的功能、简化代码就继承了类，类的继承必须是类之间有所属关系才能继续。（所属关系：is a）

如何使用一个继承体系中的功能呢？
	想要使用体系，先查阅体系父类的描述，因为父类中定义的是该类体系中共性功能，通过了解共性功能，就可以知道
		该体系的基本功能，那么这个体系已经基本可以使用。在具体调用时，要创建子类对象。
		简单说就是：查阅父类功能，创建子类对象使用功能。
	为什么:1、因为可能父类不能创建对象。
		   2、创建子类对象可以使用更多的功能，包括子类特有的。
		   
注意：如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量用this，要访问父类中的同名变量用super。


----------------------------------------子类的实例化过程--------------------------------------------------------

1、在子类是构造函数中，必须调用父类的构造函数。
2、如果子类中没有明确调用哪个父类的构造函数，编译器会自动添加super();
3、用super调用父类的构造函数，消除子类构造函数中的重复代码。
4、super要放在构造函数中的第一条语句。

为什么子类一定要访问父类中的构造函数？
	因为父类中的数据子类可以直接获取，所以子类对象建立时，需要看父类是如何对这些数据进行初始化的。
		如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。
	



---------------------------------------函数的复写(override)--------------------------------------------------	

什么是复写：	
	1、在具有父子关系的两个类当中。
	2、父类和子类各有一个函数，这两个函数的定义（返回值类型，函数名和参数列表）完全相同
	
使用super来调用父类的函数。

当子类继承了父类，沿袭了父类的功能到子类中，但是子类虽然具备该功能，但功能的内部却和父类不一致，这时，没有必要
	定义新功能，而使用覆盖，保留父类的功能定义，并重写该功能。
	
注意：1、子类覆盖父类，必须保证子类权限大于或等于父类权限，才能覆盖，否则编译失败。
	  2、静态中能覆盖静态。	

---------------------------------------------static关键字的作用---------------------------------------------------	

作用：
	1、定义静态成员变量：静态成员变量可以用类名直接调用。当对象中出现共享数据时，该数据就被静态所修饰，存在于方法区，
		对象中的特有数据就定义成非静态，存在于堆内存中。
	2、定义静态成员方法：静态成员方法中不能包含非静态成员变量。功能内部没有访问到非静态成员数据（对象特有数据）
		那么该功能就可以定义成静态的。
	3、定义静态代码块：静态代码块是在类装载的时候运行的。
	
	
注意：静态成员变量在内存中只有一份，在静态函数中不能使用this，静态代码块主要作用是为静态成员变量赋值。

静态在内存中，不存在于堆内存中，而是存在于方法区（或叫共享区或数据区），可以单独存取。

static的特点：
	1、随着类的加载而加载，随着类的消失而消失。
	2、优先于对象存在。（静态先存在，对象后存在）
	3、被所有对象所共享。
	4、可以直接被类名所调用。
	
实例变量和类变量的区别？
	1、存放位置：类变量随着类的加载而存在于方法区中。
				 实例变量随着对象的建立而存在于堆内存中。
	2、生命周期：类变量生命周期最长，随着类的消失而消失。
				 实例变量生命周期随着对象的消失而消失。
				 
（重点）静态的使用注意事项：
	1、静态方法只能访问静态成员（变量和方法）。非静态方法既能访问静态成员，又可以访问非静态成员（变量和方法）。
	2、静态方法中不可以有this、super关键字，因为静态优先于对象存在，所以不可以有this、super。
	3、主函数是静态的。
	
使用静态的利弊：
	利：对对象的共性数据进行单独空间存储，节省空间，没有必要每一个对象中都存储一份，而可以被类名直接调用。
	弊：生命周期过长，访问出现局限性（静态虽好，只能访问静态成员）。
	
	
--------------------------------------主函数----------------------------------------------------
	
主函数：是一个特殊的函数，作为程序的入口，可以被java虚拟机（JVM）调用。
主函数的定义：
	public：函数的访问权限是最大的。
	static：代表着主函数随着类的加载就已经存在。
	void：主函数没有具体返回值。
	main：不是关键字，但是是一个特殊的单词，能被JVM所识别。
	String[] args:函数参数。参数是一个数组，该数组中的元素是字符串，即字符串类型的数组。
	JVM在调用主函数时传入的是new String[0];
	
------------------------------------------对象的转型---------------------------------------------------------------
	
什么是向上转型：
	将子类的对象赋值给父类的引用。
		eg：Person p = new Student();
		
什么是向下转型：
	将父类的引用赋值给子类的引用。向下转型的前提是先进行向上转型。
		eg：Person p = new Student();
			Student s2 = (Student)p;
			
多态的规则：
	1、多态自始至终都是子类对象在做着变化。
	2、一个引用能够调用哪些成员（变量和函数），取决于这个引用的类型。
	3、一个引用调用的是哪一个方法，取决于这个引用所指向的对象。
	4、非静态成员函数在多态调用时，编译时看左边，运行时看右边。
	5、在多态中，成员变量，无论编译还是运行，都是参考左边。（引用型变量所属的类）
	6、在多态中，静态成员函数，无论编译还是运行，都参考左边。
	
类类型的判断：
	类名 instanceOf 类名     返回值为boolean。


-----------------------------------包和访问权限--------------------------------------------------------

1、将类放置到一个包中，需要使用package"包名"。
2、编译时需要使用-d参数，该参数的作用是依据包名生成相应的文件夹。
3、一个类的全名应该是"包名" + "." + "类名"。
4、包名的命名规范：
	1、要求包名所有的字母都是小写。
	2、包名一般情况下是你的域名倒过来写。
	
java当中的访问权限：public > protected > default > private
	1、public：公共权限：可以修饰类、成员变量和成员函数。没有任何访问权限，同一包中或者不同包中的类可以自由访问。
	2、private：私有权限：可以修饰成员变量和成员函数。只能在本类中使用。私有权限是封装的一种表现形式。
	3、default：包级别访问权限（默认权限）：可以修饰类、成员变量和成员函数。在同一个包中可以自由访问。
	4、protected：受保护权限：protected权限首先拥有和default权限一样的功能，其次又可以访问父类中有足够访问权限的成员。
		该权限只能修饰成员变量和成员函数。
		如果子类和父类不在同一个包中，子类可以继承到父类当中的default权限的成员变量和成员函数，但是由于权限不够，无法使用。
		
		
	
-----------------------------------equals方法和"=="------------------------------------------------------

简单说，"=="一般用于基本数据类型的比较，而equals一般用于引用数据类型的比较。

在Java规范中，它对equals()方法的使用必须要遵循如下几个规则：
	equals 方法在非空对象引用上实现相等关系：
		1、自反性：对于任何非空引用值 x，x.equals(x) 都应返回 true。
		2、对称性：对于任何非空引用值 x 和 y，当且仅当 y.equals(x) 返回 true 时，x.equals(y) 才应返回 true。
		3、传递性：对于任何非空引用值 x、y 和 z，如果 x.equals(y) 返回 true，并且 y.equals(z) 返回 true，
			那么 x.equals(z) 应返回 true。
		4、一致性：对于任何非空引用值 x 和 y，多次调用 x.equals(y) 始终返回 true 或始终返回 false，
			前提是对象上 equals 比较中所用的信息没有被修改。
		5、 对于任何非空引用值 x，x.equals(null) 都应返回 false。  
	对于上面几个规则，我们在使用的过程中最好遵守，否则会出现意想不到的错误。

在java中进行比较，我们需要根据比较的类型来选择合适的比较方式：
	1) 对象域，使用equals方法 。 
	2) 类型安全的枚举，使用equals或== 。 
	3) 可能为null的对象域 : 使用 == 和 equals 。 
	4) 数组域 : 使用 Arrays.equals 。 
	5) 除float和double外的原始数据类型 : 使用 == 。 
	6) float类型: 使用Float.foatToIntBits转换成int类型，然后使用==。  
	7) double类型: 使用Double.doubleToLongBit转换成long类型，然后使用==。
	至于6）、7）为什么需要进行转换，我们可以参考他们相应封装类的equals()方法，
	
重写equals方法的要点： 
	1. 使用==操作符检查“实参是否为指向对象的一个引用”。 
	2. 使用instanceof操作符检查“实参是否为正确的类型”。 
	3. 把实参转换到正确的类型。 
	4. 对于该类中每一个“关键”域，检查实参中的域与当前对象中对应的域值是否匹配。
		(1)、对于既不是float也不是double类型的基本类型的域，可以使用==操作符进行比较；
		(2)、对于对象引用类型的域，可以递归地调用所引用的对象的equals方法； 
	　　(3)、对于float类型的域，先使用Float.floatToIntBits转换成int类型的值，然后使用==操作符比较int类型的值；
		(4)、对于double类型的域，先使用Double.doubleToLongBits转换成long类型的值，然后使用==操作符比较long类型的值。 
	5. 当你编写完成了equals方法之后，应该问自己三个问题：它是否是对称的、传递的、一致的？(其他两个特性通常会自行满足)
		如果答案是否定的，那么请找到这些特性未能满足的原因，再修改equals方法的代码。
		

--------------------------------------toString方法-----------------------------------------------------------		

		toString()方法在Object类中定义，其返回值是String类型，描述当前对象的有关信息在进行String与其它
	类型数据的连接操作时，自动调用toString()方法可以根据需要在用户自定义类型中重写toString()方法
	基本类型数据转换为String类型时，调用了对应封装类的toString()方法。


--------------------------------------final的作用--------------------------------------------------------

final:用作修饰符
	1、可以修饰函数、变量和类。
	2、被final修饰的类不可以被继承。可以避免被继承后子类复写功能。
	3、被final修饰的方法不可以被复写。
	4、被final修饰的变量是一个常量，只能被赋值一次，即可以修饰成员变量，又可以修饰局部变量。
		当在描述事物时，一些数据的出现值是固定的，那么这时为了增强阅读性，都给这些值起一个名字，方便阅读。
			而这个值不需要改变，所以加上final修饰。
			作为常量，常量的书写规范是所有的字母都大写，单词间用_连接。
	5、内部类定义在类中的局部位置上，只能访问该局部被final修饰的局部变量。
			
		
----------------------------------------多态----------------------------------------------------------------
	
多态：事物存在的多种体现形态。
1、多态的体现：
	父类的引用指向了自己的子类对象。
	
2、多态的前提：
	1、必须是类与类之间有关系，要么继承，要么实现。
	2、存在覆盖。
	
3、多态的好处：
	多态的出现，大大提高了程序的扩展性。
	
4、多态的弊端：
	提高了扩展性，但是只能使父类的引用访问父类中的成员（成员变量和成员函数）。
	
	

----------------------------------抽象类和抽象函数-----------------------------------------------------------------

什么是抽象函数：
	只有函数的定义，没有函数体的函数。
		eg：abstract void fun();
		
什么是抽象类：使用abstract定义的类。
	1、抽象类不能够生成对象。
	2、如果一个类中，包含有抽象函数，那么这个类必须声明为抽象类。
	3、如果一个类当中没有抽象函数，那么这个类也可以被声明为抽象类。（不让类生成对象）
	
抽象类是有构造函数的。

抽象类的特点：
	1、抽象方法一定在抽象类中。
	2、抽象方法和抽象类必须被abstract关键字修饰。
	3、抽象类不可以使用new创建对象，因为调用抽象方法无意义。
	4、抽象类中的方法要被使用，必须由子类复写抽象方法后，建立子类对象调用。如果子类只复写
		部分抽象方法，那么子类仍然是抽象类。
		
抽象类与一般类没有太大不同，只不过抽象类中有些部分功能需要明确出现，但又无法定义主体，通过
	抽象方法来表示。抽象类中可以定义抽象方法，不可以被实例化。



-------------------------------------接口的基本语法----------------------------------------------------------------------

接口：定义了接口就定义了调用对象的标准。接口是功能的扩展。接口不可以创建对象，必须被子类覆写后才能实例化。

接口的基本语法：
	1、使用interface定义。
	2、接口当中的方法都是抽象方法。
	3、接口当中的成员都是public权限。
	4、实现接口使用implements关键字。
	5、一个类可以实现多个接口。
	6、一个接口可以继承多个接口。

类与接口之间的关系：
	类与类是继承关系。
	类与接口是实现关系。
	接口与接口是继承关系。
	
接口定义时的格式特点：
	1、接口中常见定义：常量和抽象方法。
	2、接口中的成员都是有固定的修饰符：
		常量：public static final
		方法：public abstract
		如果没有写明，编译器会自动添加。
		
继承：is a ，简单说就是你是我的一种。（必备）
接口：like a，简单说就是你像我这种。（扩展）



	
--------------------------------------java中的异常-----------------------------------------------

什么是异常:异常是中断了正常指令流的事件。

异常的由来：
	出现问题也是现实生活中一个具体的事物，也可以通过java的类的形式进行描述，并封装成对象，其实就是java
		对不正常情况进行描述后的对象体现。
		
异常的分类：(Throwable)
	|--Exception：异常
		|--checkException：编译时检测的异常。
		|--RuntimeException(uncheckException):运行时异常，编译时不检测的异常。
	|--Error:错误
	
RuntimeException：是一个特殊子类异常：
	1、如果在函数内抛出该异常，函数可以不用声明，编译一样通过。
	2、如果在函数上声明了异常，调用者可以不进行处理，编译一样通过，之所以不用在函数内声明，是因为不需要
		让调用者处理。当该异常发生时，希望程序停止，因为程序已经无法继续运算，希望停止后对代码进行修正。
		
对异常的处理方式:
	当程序有可能发生异常时，需要用throw或throws对异常进行抛出。
		1、throws用于函数上，throw用于函数内。
		2、throws后面跟异常类，可以跟多个，用逗号隔开，throw后面跟异常对象。
	对程序抛出的异常的处理方式：
		格式1：try{	} catch(  ){	} finally{	}
		格式2：try{	} catch(  ){	}
		格式3：try{	} finally{	}
	程序中，有catch就叫有对问题进行处理，没有catch就代表问题没有处理。如果异常是检测异常就必须声明。
	1、声明异常时，建议声明更为具体的异常，这样可以处理得更具体。
	2、对方声明了几个异常，就对应几个catch块，不要定义多余的catch块，如果多个catch块中的异常出现继承关系，
		父类异常catch块放在最后面。
	3、在进行catch处理时，一定要定义具体的处理方式，不要简单的定义一句e.printStackTrace();也不要简单打印
		一条输出语句。
		
异常类里的方法：
	getMessage():得到异常信息。
	toString():得到异常信息名称和异常信息。
	printStackTrace():得到异常信息名称、异常信息和异常出现的位置。
		JVM默认处理异常就是调用printStackTrace()方法，打印异常在堆栈的跟踪信息。
		
自定义异常：必须是自定义类继承Exception
	原因：异常体系有一个特点：因为异常类和异常对象都被抛出。他们都具有可抛性，这是throwable这个体系中独有的
		特性，只有这个体系中的类和对象可以被throw和throws操作。
	自定义异常时，如果该异常发生后无法再继续运算，就让这个异常继承RuntimeException.
	
异常在子父类覆盖中的体现：
	1、子类在覆盖父类时，如果父类的方法抛出异常，那么子类的覆盖方法只能抛出父类的异常或该异常的子类或处理掉异常。
	2、如果父类方法抛出多个异常，那么子类在覆盖该方法时，只能抛出父类异常的子集。
	3、如果父类或接口的方法中没有异常抛出，那么子类在覆盖方法时，也不可以抛出异常，如果子类方法出现异常，就必须
		进行try处理，绝对不能抛。
	

	 
----------------------------------------模板方法设计模式----------------------------------------------------------
	
什么是模板方法设计模式：
	在定义功能时，功能的一部分是确定的，但是有一部分是不确定的，而确定的部分在使用不确定的部分，那么这时就将不确定
		的部分暴露出去，由该类的子类去完成。


-------------------------------------简单静态工厂方法模式--------------------------------------------

	将生成对象的方法封装在一个静态的方法中，供用户直接调用，而用户并不需要关心子类与父类有多少继承关系。
	























