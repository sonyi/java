/*
-------------------------------继承初步------------------------------------------------
	
什么是继承：
	在面向对象的世界中，继承就是一个类得到另一个类当中的成员变量和成员方法。（extends）

java中只支持单继承。使用继承是为了减少重复代码。

继承的特点：
	1、提高代码的复用性。
	2、让类与类之间产生了关系，有了这个关系，才有了多态的特征。

注意：千万不要为了获取其他类中的功能、简化代码就继承了类，类的继承必须是类之间有所属关系才能继续。（所属关系：is a）

如何使用一个继承体系中的功能呢？
	想要使用体系，先查阅体系父类的描述，因为父类中定义的是该类体系中共性功能，通过了解共性功能，就可以知道
		该体系的基本功能，那么这个体系已经基本可以使用。在具体调用时，要创建子类对象。
		简单说就是：查阅父类功能，创建子类对象使用功能。
	为什么:1、因为可能父类不能创建对象。
		   2、创建子类对象可以使用更多的功能，包括子类特有的。
		   
注意：如果子类中出现非私有的同名成员变量时，子类要访问本类中的变量用this，要访问父类中的同名变量用super。


----------------------------------------子类的实例化过程------------------------------------

1、在子类是构造函数中，必须调用父类的构造函数。
2、如果子类中没有明确调用哪个父类的构造函数，编译器会自动添加super();
3、用super调用父类的构造函数，消除子类构造函数中的重复代码。
4、super要放在构造函数中的第一条语句。

为什么子类一定要访问父类中的构造函数？
	因为父类中的数据子类可以直接获取，所以子类对象建立时，需要看父类是如何对这些数据进行初始化的。
		如果要访问父类中指定的构造函数，可以通过手动定义super语句的方式来指定。
			

--------------------------------------局部变量和全局变量---------------------------------------
	
局部变量和全局变量的区别：
	1、全局变量定义在类中但在任何方法之外。（New出来的均有初值），而局部变量定义在方法之中的变量。
	2、局部变量要先赋值，再进行运算，而全局变量均已经赋初值。这是局部变量和实例变量的一大区别。
	3、全局变量的对象赋值为null。
	4、局部变量不允许范围内定义两个同名变量。全局变量的作用域在本类中完全有效，
		当被其他的类调用的时候也可能有效。全局变量和局部变量允许命名冲突。
	
	
------------------------------------构造方法----------------------------------------------

构造方法：类方法中的一类特殊方法
	1、构造方法是当用类生成对象时，系统在生成对象的过程中利用的方法。
	2、构造方法在生成对象的时候会被调用，但并不是构造方法生成了对象。
	3、构造方法没有返回值。格式为：public 方法名。
	4、构造方法的方法名与类名相同。
	5、构造方法是在对象生成的过程中自动调用，不可能利用指令去调用。
	6、在一个对象的生成周期中构造方法只用一次，一旦这个对象生成，那么这个构造方法失效。
	7、一个类可以构造多个构造方法，但多个构造方法的参数表一定不同，参数顺序不同即属于不同的构造方法：
		eg：public student(string name,int a){	}
			public student(int a,string name){	}
			这是两个不同的构造方法。
	8、如果我们未给系统提供一个构造方法，那么系统会自动提供一个为空的构造方法。
	
	
--------------------------------覆盖(override)-------------------------------------------

什么是复写(覆盖)：	
	1、在具有父子关系的两个类当中。
	2、父类和子类各有一个函数，这两个函数的定义（返回值类型，函数名和参数列表）完全相同
	
使用super来调用父类的函数。

当子类继承了父类，沿袭了父类的功能到子类中，但是子类虽然具备该功能，但功能的内部却和父类不一致，这时，没有必要
	定义新功能，而使用覆盖，保留父类的功能定义，并重写该功能。
	
注意：1、子类覆盖父类，必须保证子类权限大于或等于父类权限，才能覆盖，否则编译失败。
	  2、静态中能覆盖静态。	
	
-----------------------------重载(overload)-------------------------------------------	

重载（overloading）：	
	1、Overloading在一个类中可以定义多个同名方法，各个方法的参数表一定不同。但修饰词可能相同，返回值也可能相同。
	2、在程序的编译过程中根据变量类型来找相应的方法。因此也有人认为 overloading是编译时的多态，以后我们还会学到运行时多态。

构造方法的重载形式：
	例：public  void  teach(){};
		public  void  teach(int a){};
		public  void  teach(String a){}为三种不同的方法。

Overloading方法是从低向高转。
	Byte―short―float―int―long―double。

-----------------------------this关键字-------------------------------------------	

	Java关键字this只能用于方法方法体内。当一个对象创建后，Java虚拟机（JVM）就会给这个对象分配
一个引用自身的指针，这个指针的名字就是this。因此，this只能在类中的非静态方法中使用，静态方法和
静态的代码块中绝对不能出现this。并且this只和特定的对象关联，而不和类关联，同一个类的不同对象有不同的this。
	
this的使用方法：
	第一、通过this调用另一个构造方法，用发是this(参数列表)，这个仅仅在类的构造方法中，别的地方不能这么用。
    第二、函数参数或者函数中的局部变量和成员变量同名的情况下，成员变量被屏蔽，此时要访问成员变量则需要用
		“this.成员变量名”的方式来引用成员变量。当然，在没有同名的情况下，可以直接用成员变量的名字。
    第三、在函数中，需要引用该函所属类的当前对象时候，直接用this。
    其实这些用法总结都是从对“this是指向对象本身的一个指针”这句话的更深入的理解而来的！
	
-----------------------------super关键字-------------------------------------------	

	super关键和this作用类似，是被屏蔽的成员变量或者成员方法或变为可见，或者说用来引用被屏蔽的成员变量
和成员成员方法。不过super是用在子类中，目的是访问直接父类中被屏蔽的成员，注意是直接父类（就是类之上最近的超类）。

super的使用方法：
	第一、在子类构造方法中要调用父类的构造方法，用“super(参数列表)”的方式调用，参数不是必须的。
		同时还要注意的一点是：“super(参数列表)”这条语句只能用在子类构造方法体中的第一行。
    第二、当子类方法中的局部变量或者子类的成员变量与父类成员变量同名时，也就是子类局部变量覆盖父类成员变量时，
		用“super.成员变量名”来引用父类成员变量。当然，如果父类的成员变量没有被覆盖，也可以用“super.成员变量名”
		来引用父类成员变量，不过这是不必要的。
    第三、当子类的成员方法覆盖了父类的成员方法时，也就是子类和父类有完全相同的方法定义（但方法体可以不同），
		此时，用“super.方法名(参数列表)”的方式访问父类的方法。
		
*/